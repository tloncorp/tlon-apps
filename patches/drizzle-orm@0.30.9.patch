diff --git a/op-sqlite/session.cjs b/op-sqlite/session.cjs
index f1ce597e8a6e0e325788cac540a8fde32d36bb42..23c02a93a5cae29b0b66b03eb73c13a79e547c09 100644
--- a/op-sqlite/session.cjs
+++ b/op-sqlite/session.cjs
@@ -49,33 +49,23 @@ class OPSQLiteSession extends import_session.SQLiteSession {
       customResultMapper
     );
   }
-  transaction(transaction, config = {}) {
-    const tx = new OPSQLiteTransaction("async", this.dialect, this, this.schema);
-    this.run(import_sql.sql.raw(`begin${config?.behavior ? " " + config.behavior : ""}`));
-    try {
-      const result = transaction(tx);
-      this.run(import_sql.sql`commit`);
-      return result;
-    } catch (err) {
-      this.run(import_sql.sql`rollback`);
-      throw err;
-    }
+  transaction(transaction, _config = {}) {
+    return new Promise((resolve, reject) => {
+      this.client.transaction(async () => {
+        const tx = new OPSQLiteTransaction("async", this.dialect, this, this.schema);
+        try {
+          resolve(await transaction(tx));
+        } catch (e) {
+          reject(e);
+        }
+      });
+    });
   }
 }
 class OPSQLiteTransaction extends import_sqlite_core.SQLiteTransaction {
   static [import_entity.entityKind] = "OPSQLiteTransaction";
-  transaction(transaction) {
-    const savepointName = `sp${this.nestedIndex}`;
-    const tx = new OPSQLiteTransaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
-    this.session.run(import_sql.sql.raw(`savepoint ${savepointName}`));
-    try {
-      const result = transaction(tx);
-      this.session.run(import_sql.sql.raw(`release savepoint ${savepointName}`));
-      return result;
-    } catch (err) {
-      this.session.run(import_sql.sql.raw(`rollback to savepoint ${savepointName}`));
-      throw err;
-    }
+  transaction(_transaction) {
+    throw new Error("nested transactions not implemented for op-sqlite, sorry!");
   }
 }
 class OPSQLitePreparedQuery extends import_session.SQLitePreparedQuery {
diff --git a/op-sqlite/session.cjs.map b/op-sqlite/session.cjs.map
index 524b98c878a43d34c1f755d21a25f6bfcd691cc3..7b3135dc8a0802cd825d10b34f0ff95cb9579df8 100644
--- a/op-sqlite/session.cjs.map
+++ b/op-sqlite/session.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/op-sqlite/session.ts"],"sourcesContent":["import type { OPSQLiteConnection, QueryResult } from '@op-engineering/op-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface OPSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class OPSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: OPSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): OPSQLitePreparedQuery<T> {\n\t\treturn new OPSQLitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class OPSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'async'; run: QueryResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic readonly [entityKind]: string = 'OPSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): Promise<QueryResult> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\treturn this.client.executeAsync(this.query.sql, params);\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { fields, joinsNotNullableMap, query, logger, customResultMapper, client } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\n\t\t\treturn client.execute(query.sql, params).rows?._array || [];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { fields, joinsNotNullableMap, customResultMapper, query, logger, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst rows = client.execute(query.sql, params).rows?._array || [];\n\t\t\treturn rows[0];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.client.executeRawAsync(this.query.sql, params);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":["rows"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/op-sqlite/session.ts"],"sourcesContent":["import type { OPSQLiteConnection, QueryResult } from '@op-engineering/op-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface OPSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class OPSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: OPSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): OPSQLitePreparedQuery<T> {\n\t\treturn new OPSQLitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T | Promise<T>,\n\t\t_config: SQLiteTransactionConfig = {},\n\t): Promise<T> {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\tthis.client.transaction(async () => {\n\t\t\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this, this.schema);\n\t\t\t\ttry {\n\t\t\t\t\tresolve(await transaction(tx))\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nexport class OPSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteTransaction';\n\n\toverride transaction<T>(_transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tthrow new Error(\"nested transactions not implemented for op-sqlite, sorry!\")\n\t}\n}\n\nexport class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'async'; run: QueryResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic readonly [entityKind]: string = 'OPSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): Promise<QueryResult> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\treturn this.client.executeAsync(this.query.sql, params);\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { fields, joinsNotNullableMap, query, logger, customResultMapper, client } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\n\t\t\treturn client.execute(query.sql, params).rows?._array || [];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { fields, joinsNotNullableMap, customResultMapper, query, logger, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst rows = client.execute(query.sql, params).rows?._array || [];\n\t\t\treturn rows[0];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.client.executeRawAsync(this.query.sql, params);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":["rows"]}
\ No newline at end of file
diff --git a/op-sqlite/session.d.cts b/op-sqlite/session.d.cts
index a0429e5e06e85a0f1ab77c2fddf1cb1f8ae9dfd8..7208cfbd85049019e14ce43d1814ebaeaa9c54a8 100644
--- a/op-sqlite/session.d.cts
+++ b/op-sqlite/session.d.cts
@@ -18,11 +18,11 @@ export declare class OPSQLiteSession<TFullSchema extends Record<string, unknown>
     private logger;
     constructor(client: OPSQLiteConnection, dialect: SQLiteAsyncDialect, schema: RelationalSchemaConfig<TSchema> | undefined, options?: OPSQLiteSessionOptions);
     prepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(query: Query, fields: SelectedFieldsOrdered | undefined, executeMethod: SQLiteExecuteMethod, isResponseInArrayMode: boolean, customResultMapper?: (rows: unknown[][]) => unknown): OPSQLitePreparedQuery<T>;
-    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T, config?: SQLiteTransactionConfig): T;
+    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T | Promise<T>, _config?: SQLiteTransactionConfig): Promise<T>;
 }
 export declare class OPSQLiteTransaction<TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {
     static readonly [entityKind]: string;
-    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T;
+    transaction<T>(_transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T;
 }
 export declare class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<{
     type: 'async';
diff --git a/op-sqlite/session.d.ts b/op-sqlite/session.d.ts
index 07cae6b6cb6c0c1a11d283ae26aad1c1c1d7cd4d..440fab0c20642ccb256b5817ef063c9ff7584872 100644
--- a/op-sqlite/session.d.ts
+++ b/op-sqlite/session.d.ts
@@ -18,11 +18,11 @@ export declare class OPSQLiteSession<TFullSchema extends Record<string, unknown>
     private logger;
     constructor(client: OPSQLiteConnection, dialect: SQLiteAsyncDialect, schema: RelationalSchemaConfig<TSchema> | undefined, options?: OPSQLiteSessionOptions);
     prepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(query: Query, fields: SelectedFieldsOrdered | undefined, executeMethod: SQLiteExecuteMethod, isResponseInArrayMode: boolean, customResultMapper?: (rows: unknown[][]) => unknown): OPSQLitePreparedQuery<T>;
-    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T, config?: SQLiteTransactionConfig): T;
+    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T | Promise<T>, _config?: SQLiteTransactionConfig): Promise<T>;
 }
 export declare class OPSQLiteTransaction<TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {
     static readonly [entityKind]: string;
-    transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T;
+    transaction<T>(_transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T;
 }
 export declare class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<{
     type: 'async';
diff --git a/op-sqlite/session.js b/op-sqlite/session.js
index ff84604e7998182ef78fbffc8d20019aaf76755e..6128c68e58ef3bec0eaf05452587dfae959401a6 100644
--- a/op-sqlite/session.js
+++ b/op-sqlite/session.js
@@ -1,6 +1,6 @@
 import { entityKind } from "../entity.js";
 import { NoopLogger } from "../logger.js";
-import { fillPlaceholders, sql } from "../sql/sql.js";
+import { fillPlaceholders } from "../sql/sql.js";
 import { SQLiteTransaction } from "../sqlite-core/index.js";
 import {
   SQLitePreparedQuery,
@@ -27,33 +27,23 @@ class OPSQLiteSession extends SQLiteSession {
       customResultMapper
     );
   }
-  transaction(transaction, config = {}) {
-    const tx = new OPSQLiteTransaction("async", this.dialect, this, this.schema);
-    this.run(sql.raw(`begin${config?.behavior ? " " + config.behavior : ""}`));
-    try {
-      const result = transaction(tx);
-      this.run(sql`commit`);
-      return result;
-    } catch (err) {
-      this.run(sql`rollback`);
-      throw err;
-    }
+  transaction(transaction, _config = {}) {
+    return new Promise((resolve, reject) => {
+      this.client.transaction(async () => {
+        const tx = new OPSQLiteTransaction("async", this.dialect, this, this.schema);
+        try {
+          resolve(await transaction(tx));
+        } catch (e) {
+          reject(e);
+        }
+      });
+    });
   }
 }
 class OPSQLiteTransaction extends SQLiteTransaction {
   static [entityKind] = "OPSQLiteTransaction";
-  transaction(transaction) {
-    const savepointName = `sp${this.nestedIndex}`;
-    const tx = new OPSQLiteTransaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
-    this.session.run(sql.raw(`savepoint ${savepointName}`));
-    try {
-      const result = transaction(tx);
-      this.session.run(sql.raw(`release savepoint ${savepointName}`));
-      return result;
-    } catch (err) {
-      this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
-      throw err;
-    }
+  transaction(_transaction) {
+    throw new Error("nested transactions not implemented for op-sqlite, sorry!");
   }
 }
 class OPSQLitePreparedQuery extends SQLitePreparedQuery {
diff --git a/op-sqlite/session.js.map b/op-sqlite/session.js.map
index 7484b6b1d567f1db2af3859c665e2540d0420ae5..8ae24e6dc7fb2c8b6c354aefeeaca23635c9876d 100644
--- a/op-sqlite/session.js.map
+++ b/op-sqlite/session.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/op-sqlite/session.ts"],"sourcesContent":["import type { OPSQLiteConnection, QueryResult } from '@op-engineering/op-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface OPSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class OPSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: OPSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): OPSQLitePreparedQuery<T> {\n\t\treturn new OPSQLitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class OPSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'async'; run: QueryResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic readonly [entityKind]: string = 'OPSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): Promise<QueryResult> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\treturn this.client.executeAsync(this.query.sql, params);\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { fields, joinsNotNullableMap, query, logger, customResultMapper, client } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\n\t\t\treturn client.execute(query.sql, params).rows?._array || [];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { fields, joinsNotNullableMap, customResultMapper, query, logger, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst rows = client.execute(query.sql, params).rows?._array || [];\n\t\t\treturn rows[0];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.client.executeRawAsync(this.query.sql, params);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":["rows"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/op-sqlite/session.ts"],"sourcesContent":["import type { OPSQLiteConnection, QueryResult } from '@op-engineering/op-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface OPSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class OPSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: OPSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): OPSQLitePreparedQuery<T> {\n\t\treturn new OPSQLitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T | Promise<T>,\n\t\t_config: SQLiteTransactionConfig = {},\n\t): Promise<T> {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\tthis.client.transaction(async () => {\n\t\t\t\tconst tx = new OPSQLiteTransaction('async', this.dialect, this, this.schema);\n\t\t\t\ttry {\n\t\t\t\t\tresolve(await transaction(tx))\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nexport class OPSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'async', QueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'OPSQLiteTransaction';\n\n\toverride transaction<T>(_transaction: (tx: OPSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tthrow new Error(\"nested transactions not implemented for op-sqlite, sorry!\")\n\t}\n}\n\nexport class OPSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'async'; run: QueryResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic readonly [entityKind]: string = 'OPSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate client: OPSQLiteConnection,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): Promise<QueryResult> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\treturn this.client.executeAsync(this.query.sql, params);\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { fields, joinsNotNullableMap, query, logger, customResultMapper, client } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\n\t\t\treturn client.execute(query.sql, params).rows?._array || [];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { fields, joinsNotNullableMap, customResultMapper, query, logger, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst rows = client.execute(query.sql, params).rows?._array || [];\n\t\t\treturn rows[0];\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.client.executeRawAsync(this.query.sql, params);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":["rows"]}
