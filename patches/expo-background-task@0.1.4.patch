diff --git a/build/BackgroundTask.d.ts b/build/BackgroundTask.d.ts
index a0e33593e56c100095662f642258d14755bab38f..f228f179171405f0b9d633b094b810aaa757309f 100644
--- a/build/BackgroundTask.d.ts
+++ b/build/BackgroundTask.d.ts
@@ -47,5 +47,6 @@ export declare function unregisterTaskAsync(taskName: string): Promise<void>;
  * @todo(chrfalch): When we have a usable devtools plugin we can enable this function.
  * @returns A promise which fulfils when the task is triggered.
  */
+export declare function triggerTaskWorkerForTestingAsync(): Promise<boolean>;
 export { BackgroundTaskStatus, BackgroundTaskResult, BackgroundTaskOptions, } from './BackgroundTask.types';
 //# sourceMappingURL=BackgroundTask.d.ts.map
\ No newline at end of file
diff --git a/build/BackgroundTask.d.ts.map b/build/BackgroundTask.d.ts.map
index 18faefa9db8aeeab1296fab834dcff476a7b0824..27c6f98c0a87c18a321e2ed37e25bb87fafd68d6 100644
--- a/build/BackgroundTask.d.ts.map
+++ b/build/BackgroundTask.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"BackgroundTask.d.ts","sourceRoot":"","sources":["../src/BackgroundTask.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,qBAAqB,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAOrF;;;;;GAKG;AACH,eAAO,MAAM,cAAc,QAAa,QAAQ,oBAAoB,CAMnE,CAAC;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,wBAAsB,iBAAiB,CACrC,QAAQ,EAAE,MAAM,EAChB,OAAO,GAAE,qBAA0B,GAClC,OAAO,CAAC,IAAI,CAAC,CAwBf;AAGD;;;;GAIG;AACH,wBAAsB,mBAAmB,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAQzE;AAGD;;;;;GAKG;AAcH,OAAO,EACL,oBAAoB,EACpB,oBAAoB,EACpB,qBAAqB,GACtB,MAAM,wBAAwB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"BackgroundTask.d.ts","sourceRoot":"","sources":["../src/BackgroundTask.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,qBAAqB,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAOrF;;;;;GAKG;AACH,eAAO,MAAM,cAAc,QAAa,OAAO,CAAC,oBAAoB,CAMnE,CAAC;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,wBAAsB,iBAAiB,CACrC,QAAQ,EAAE,MAAM,EAChB,OAAO,GAAE,qBAA0B,GAClC,OAAO,CAAC,IAAI,CAAC,CAwBf;AAGD;;;;GAIG;AACH,wBAAsB,mBAAmB,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAQzE;AAGD;;;;;GAKG;AACH,wBAAsB,gCAAgC,IAAI,OAAO,CAAC,OAAO,CAAC,CAUzE;AAGD,OAAO,EACL,oBAAoB,EACpB,oBAAoB,EACpB,qBAAqB,GACtB,MAAM,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/build/BackgroundTask.js b/build/BackgroundTask.js
index 9ae7046e7f1db8122a9524e7c33e040933bde6a2..ce50aeefb51ee86290493e71aae2730610112e2f 100644
--- a/build/BackgroundTask.js
+++ b/build/BackgroundTask.js
@@ -90,17 +90,18 @@ export async function unregisterTaskAsync(taskName) {
  * @todo(chrfalch): When we have a usable devtools plugin we can enable this function.
  * @returns A promise which fulfils when the task is triggered.
  */
-// export async function triggerTaskWorkerForTestingAsync(): Promise<boolean> {
-//   if (__DEV__) {
-//     if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {
-//       throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');
-//     }
-//     console.log('Calling triggerTaskWorkerForTestingAsync');
-//     return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();
-//   } else {
-//     return Promise.resolve(false);
-//   }
-// }
+export async function triggerTaskWorkerForTestingAsync() {
+    if (__DEV__) {
+        if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {
+            throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');
+        }
+        console.log('Calling triggerTaskWorkerForTestingAsync');
+        return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();
+    }
+    else {
+        return Promise.resolve(false);
+    }
+}
 // Export types
 export { BackgroundTaskStatus, BackgroundTaskResult, } from './BackgroundTask.types';
 //# sourceMappingURL=BackgroundTask.js.map
\ No newline at end of file
diff --git a/build/BackgroundTask.js.map b/build/BackgroundTask.js.map
index 70e8e395f78e20c3e4cbeedfe271611c7a3273d5..384562c934d809281a110b14ff1a5de352e5a798 100644
--- a/build/BackgroundTask.js.map
+++ b/build/BackgroundTask.js.map
@@ -1 +1 @@
-{"version":3,"file":"BackgroundTask.js","sourceRoot":"","sources":["../src/BackgroundTask.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAClE,OAAO,KAAK,WAAW,MAAM,mBAAmB,CAAC;AAEjD,OAAO,EAAyB,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AACrF,OAAO,wBAAwB,MAAM,4BAA4B,CAAC;AAElE,gDAAgD;AAChD,IAAI,8BAA8B,GAAG,KAAK,CAAC;AAE3C,cAAc;AACd;;;;;GAKG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,KAAK,IAAmC,EAAE;IACtE,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE;QAC5C,MAAM,IAAI,mBAAmB,CAAC,gBAAgB,EAAE,gBAAgB,CAAC,CAAC;KACnE;IAED,OAAO,wBAAwB,CAAC,cAAc,EAAE,CAAC;AACnD,CAAC,CAAC;AAEF,cAAc;AACd;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CACrC,QAAgB,EAChB,UAAiC,EAAE;IAEnC,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,EAAE;QAC/C,MAAM,IAAI,mBAAmB,CAAC,gBAAgB,EAAE,mBAAmB,CAAC,CAAC;KACtE;IACD,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;QACxC,MAAM,IAAI,KAAK,CACb,SAAS,QAAQ,2FAA2F,CAC7G,CAAC;KACH;IACD,IAAI,MAAM,WAAW,CAAC,qBAAqB,CAAC,QAAQ,CAAC,EAAE;QACrD,MAAM,IAAI,KAAK,CAAC,SAAS,QAAQ,0BAA0B,CAAC,CAAC;KAC9D;IACD,IAAI,CAAC,MAAM,wBAAwB,CAAC,cAAc,EAAE,CAAC,KAAK,oBAAoB,CAAC,UAAU,EAAE;QACzF,IAAI,CAAC,8BAA8B,EAAE;YACnC,MAAM,OAAO,GACX,QAAQ,CAAC,EAAE,KAAK,KAAK;gBACnB,CAAC,CAAC,mFAAmF,QAAQ,GAAG;gBAChG,CAAC,CAAC,4FAA4F,QAAQ,GAAG,CAAC;YAC9G,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACtB,8BAA8B,GAAG,IAAI,CAAC;SACvC;QACD,OAAO;KACR;IACD,MAAM,wBAAwB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACtE,CAAC;AAED,cAAc;AACd;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,QAAgB;IACxD,IAAI,CAAC,wBAAwB,CAAC,mBAAmB,EAAE;QACjD,MAAM,IAAI,mBAAmB,CAAC,gBAAgB,EAAE,qBAAqB,CAAC,CAAC;KACxE;IACD,IAAI,CAAC,CAAC,MAAM,WAAW,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC,EAAE;QACxD,MAAM,IAAI,KAAK,CAAC,SAAS,QAAQ,sBAAsB,CAAC,CAAC;KAC1D;IACD,MAAM,wBAAwB,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;AAC/D,CAAC;AAED,cAAc;AACd;;;;;GAKG;AACH,+EAA+E;AAC/E,mBAAmB;AACnB,wEAAwE;AACxE,6FAA6F;AAC7F,QAAQ;AACR,+DAA+D;AAC/D,gFAAgF;AAChF,aAAa;AACb,qCAAqC;AACrC,MAAM;AACN,IAAI;AAEJ,eAAe;AACf,OAAO,EACL,oBAAoB,EACpB,oBAAoB,GAErB,MAAM,wBAAwB,CAAC","sourcesContent":["import { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport { BackgroundTaskOptions, BackgroundTaskStatus } from './BackgroundTask.types';\nimport ExpoBackgroundTaskModule from './ExpoBackgroundTaskModule';\n\n// Flag to warn about running on Apple simulator\nlet warnAboutRunningOniOSSimulator = false;\n\n// @needsAudit\n/**\n * Returns the status for the Background Task API. On web, it always returns `BackgroundTaskStatus.Restricted`,\n * while on native platforms it returns `BackgroundTaskStatus.Available`.\n *\n * @returns A BackgroundTaskStatus enum value or `null` if not available.\n */\nexport const getStatusAsync = async (): Promise<BackgroundTaskStatus> => {\n  if (!ExpoBackgroundTaskModule.getStatusAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'getStatusAsync');\n  }\n\n  return ExpoBackgroundTaskModule.getStatusAsync();\n};\n\n// @needsAudit\n/**\n * Registers a background task with the given name. Registered tasks are saved in persistent storage and restored once the app is initialized.\n * @param taskName Name of the task to register. The task needs to be defined first - see [`TaskManager.defineTask`](task-manager/#taskmanagerdefinetasktaskname-taskexecutor)\n * for more details.\n * @param options An object containing the background task options.\n *\n * @example\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * // Register the task outside of the component\n * TaskManager.defineTask(BACKGROUND_TASK_IDENTIFIER, () => {\n *   try {\n *     await AsyncStorage.setItem(LAST_TASK_DATE_KEY, Date.now().toString());\n *   } catch (error) {\n *     console.error('Failed to save the last fetch date', error);\n *     return BackgroundTaskResult.Failed;\n *   }\n *   return BackgroundTaskResult.Success;\n * });\n * ```\n *\n * You can now use the `registerTaskAsync` function to register the task:\n *\n * ```ts\n * BackgroundTask.registerTaskAsync(BACKGROUND_TASK_IDENTIFIER, {});\n * ```\n */\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundTaskOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundTaskModule.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  if (await TaskManager.isTaskRegisteredAsync(taskName)) {\n    throw new Error(`Task '${taskName}' is already registered.`);\n  }\n  if ((await ExpoBackgroundTaskModule.getStatusAsync()) === BackgroundTaskStatus.Restricted) {\n    if (!warnAboutRunningOniOSSimulator) {\n      const message =\n        Platform.OS === 'ios'\n          ? `Background tasks are not supported on iOS simulators. Skipped registering task: ${taskName}.`\n          : `Background tasks are not available in the current environment. Skipped registering task: ${taskName}.`;\n      console.warn(message);\n      warnAboutRunningOniOSSimulator = true;\n    }\n    return;\n  }\n  await ExpoBackgroundTaskModule.registerTaskAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Unregisters a background task, so the application will no longer be executing this task.\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfils when the task is fully unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundTaskModule.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'unregisterTaskAsync');\n  }\n  if (!(await TaskManager.isTaskRegisteredAsync(taskName))) {\n    throw new Error(`Task '${taskName}' is not registered.`);\n  }\n  await ExpoBackgroundTaskModule.unregisterTaskAsync(taskName);\n}\n\n// @needsAudit\n/**\n * When in debug mode this function will trigger running the background tasks.\n * This function will only work for apps built in debug mode.\n * @todo(chrfalch): When we have a usable devtools plugin we can enable this function.\n * @returns A promise which fulfils when the task is triggered.\n */\n// export async function triggerTaskWorkerForTestingAsync(): Promise<boolean> {\n//   if (__DEV__) {\n//     if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {\n//       throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');\n//     }\n//     console.log('Calling triggerTaskWorkerForTestingAsync');\n//     return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();\n//   } else {\n//     return Promise.resolve(false);\n//   }\n// }\n\n// Export types\nexport {\n  BackgroundTaskStatus,\n  BackgroundTaskResult,\n  BackgroundTaskOptions,\n} from './BackgroundTask.types';\n"]}
\ No newline at end of file
+{"version":3,"file":"BackgroundTask.js","sourceRoot":"","sources":["../src/BackgroundTask.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport { BackgroundTaskOptions, BackgroundTaskStatus } from './BackgroundTask.types';\nimport ExpoBackgroundTaskModule from './ExpoBackgroundTaskModule';\n\n// Flag to warn about running on Apple simulator\nlet warnAboutRunningOniOSSimulator = false;\n\n// @needsAudit\n/**\n * Returns the status for the Background Task API. On web, it always returns `BackgroundTaskStatus.Restricted`,\n * while on native platforms it returns `BackgroundTaskStatus.Available`.\n *\n * @returns A BackgroundTaskStatus enum value or `null` if not available.\n */\nexport const getStatusAsync = async (): Promise<BackgroundTaskStatus> => {\n  if (!ExpoBackgroundTaskModule.getStatusAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'getStatusAsync');\n  }\n\n  return ExpoBackgroundTaskModule.getStatusAsync();\n};\n\n// @needsAudit\n/**\n * Registers a background task with the given name. Registered tasks are saved in persistent storage and restored once the app is initialized.\n * @param taskName Name of the task to register. The task needs to be defined first - see [`TaskManager.defineTask`](task-manager/#taskmanagerdefinetasktaskname-taskexecutor)\n * for more details.\n * @param options An object containing the background task options.\n *\n * @example\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * // Register the task outside of the component\n * TaskManager.defineTask(BACKGROUND_TASK_IDENTIFIER, () => {\n *   try {\n *     await AsyncStorage.setItem(LAST_TASK_DATE_KEY, Date.now().toString());\n *   } catch (error) {\n *     console.error('Failed to save the last fetch date', error);\n *     return BackgroundTaskResult.Failed;\n *   }\n *   return BackgroundTaskResult.Success;\n * });\n * ```\n *\n * You can now use the `registerTaskAsync` function to register the task:\n *\n * ```ts\n * BackgroundTask.registerTaskAsync(BACKGROUND_TASK_IDENTIFIER, {});\n * ```\n */\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundTaskOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundTaskModule.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  if (await TaskManager.isTaskRegisteredAsync(taskName)) {\n    throw new Error(`Task '${taskName}' is already registered.`);\n  }\n  if ((await ExpoBackgroundTaskModule.getStatusAsync()) === BackgroundTaskStatus.Restricted) {\n    if (!warnAboutRunningOniOSSimulator) {\n      const message =\n        Platform.OS === 'ios'\n          ? `Background tasks are not supported on iOS simulators. Skipped registering task: ${taskName}.`\n          : `Background tasks are not available in the current environment. Skipped registering task: ${taskName}.`;\n      console.warn(message);\n      warnAboutRunningOniOSSimulator = true;\n    }\n    return;\n  }\n  await ExpoBackgroundTaskModule.registerTaskAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Unregisters a background task, so the application will no longer be executing this task.\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfils when the task is fully unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundTaskModule.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundTask', 'unregisterTaskAsync');\n  }\n  if (!(await TaskManager.isTaskRegisteredAsync(taskName))) {\n    throw new Error(`Task '${taskName}' is not registered.`);\n  }\n  await ExpoBackgroundTaskModule.unregisterTaskAsync(taskName);\n}\n\n// @needsAudit\n/**\n * When in debug mode this function will trigger running the background tasks.\n * This function will only work for apps built in debug mode.\n * @todo(chrfalch): When we have a usable devtools plugin we can enable this function.\n * @returns A promise which fulfils when the task is triggered.\n */\nexport async function triggerTaskWorkerForTestingAsync(): Promise<boolean> {\n  if (__DEV__) {\n    if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {\n      throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');\n    }\n    console.log('Calling triggerTaskWorkerForTestingAsync');\n    return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();\n  } else {\n    return Promise.resolve(false);\n  }\n}\n\n// Export types\nexport {\n  BackgroundTaskStatus,\n  BackgroundTaskResult,\n  BackgroundTaskOptions,\n} from './BackgroundTask.types';\n"]}
\ No newline at end of file
diff --git a/build/ExpoBackgroundTaskModule.web.d.ts.map b/build/ExpoBackgroundTaskModule.web.d.ts.map
index 09dc3584a7771073097a190635694250bea3938e..b18b2fbc4b9b796d4e5498129ba3142439867b4e 100644
--- a/build/ExpoBackgroundTaskModule.web.d.ts.map
+++ b/build/ExpoBackgroundTaskModule.web.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ExpoBackgroundTaskModule.web.d.ts","sourceRoot":"","sources":["../src/ExpoBackgroundTaskModule.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;;sBAGpC,QAAQ,oBAAoB,CAAC;;AADvD,wBAIE"}
\ No newline at end of file
+{"version":3,"file":"ExpoBackgroundTaskModule.web.d.ts","sourceRoot":"","sources":["../src/ExpoBackgroundTaskModule.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;;sBAGpC,OAAO,CAAC,oBAAoB,CAAC;;AADvD,wBAIE"}
\ No newline at end of file
diff --git a/ios/BackgroundTaskAppDelegate.swift b/ios/BackgroundTaskAppDelegate.swift
index b97f9180f77c4c16d828667530c5494f1fe3fb00..53ab87e7e302c450f4aa740aa5404dcd42b2022d 100644
--- a/ios/BackgroundTaskAppDelegate.swift
+++ b/ios/BackgroundTaskAppDelegate.swift
@@ -14,6 +14,16 @@ public class BackgroundTaskAppDelegateSubscriber: ExpoAppDelegateSubscriber {
         task.expirationHandler = { ()
           log.warn("Expo Background Tasks - task expired")
           task.setTaskCompleted(success: false)
+
+          // Reschedule
+          Task {
+            do {
+              log.debug("Background task successfully finished. Rescheduling")
+              try await BackgroundTaskScheduler.tryScheduleWorker()
+            } catch {
+              log.error("Could not reschedule the worker after task finished: \(error.localizedDescription)")
+            }
+          }
         }
 
         // Let's find the task service implementation and call the runTasks(withReason)
diff --git a/ios/BackgroundTaskModule.swift b/ios/BackgroundTaskModule.swift
index 6e619ddac321235838ee255d9d453e4119a7c0dd..46f5da9c51bc21ad56f5972bef9b64300d0ebd05 100644
--- a/ios/BackgroundTaskModule.swift
+++ b/ios/BackgroundTaskModule.swift
@@ -12,11 +12,7 @@ public class BackgroundTaskModule: Module {
     }
 
     AsyncFunction("triggerTaskWorkerForTestingAsync") {
-      if await BackgroundTaskScheduler.isWorkerRunning() {
-        BackgroundTaskDebugHelper.triggerBackgroundTaskTest()
-        return true
-      }
-      return false
+      BackgroundTaskDebugHelper.triggerBackgroundTaskTest()
     }
 
     AsyncFunction("registerTaskAsync") { (name: String, options: [String: Any]) in
@@ -28,7 +24,7 @@ public class BackgroundTaskModule: Module {
         throw BackgroundTasksRestricted()
       }
 
-      if !taskManager.hasBackgroundModeEnabled("processing") {
+      if !taskManager.hasBackgroundModeEnabled("fetch") {
         throw BackgroundTasksNotConfigured()
       }
 
@@ -45,7 +41,7 @@ public class BackgroundTaskModule: Module {
         throw BackgroundTasksRestricted()
       }
 
-      if !taskManager.hasBackgroundModeEnabled("processing") {
+      if !taskManager.hasBackgroundModeEnabled("fetch") {
         throw BackgroundTasksNotConfigured()
       }
 
@@ -61,7 +57,9 @@ public class BackgroundTaskModule: Module {
       Task {
         // Try start worker when app enters background
         do {
+          print("tlonDebug: app backgrounded, trying to reschedule task")
           try await BackgroundTaskScheduler.tryScheduleWorker()
+          print("tlonDebug: app backgrounded, rescheduled bg task")
         } catch {
           log.error("Could not schedule the worker: \(error.localizedDescription)")
         }
@@ -69,10 +67,11 @@ public class BackgroundTaskModule: Module {
     }
 
     OnAppEntersForeground {
-      Task {
-        // When entering foreground we'll stop the worker
-        await BackgroundTaskScheduler.stopWorker()
-      }
+      // Task {
+      //   // When entering foreground we'll stop the worker
+      //   await BackgroundTaskScheduler.stopWorker()
+      //   print("tlonDebug: app foregrounded, canceling scheduled tasks")
+      // }
     }
   }
 }
diff --git a/ios/BackgroundTaskScheduler.swift b/ios/BackgroundTaskScheduler.swift
index 20e3e590008cf187f00ce069e4f06f70e246a546..fd0bafed891d970670fc856fcb128caa04945b79 100644
--- a/ios/BackgroundTaskScheduler.swift
+++ b/ios/BackgroundTaskScheduler.swift
@@ -10,8 +10,9 @@ public class BackgroundTaskScheduler {
   /**
    * Interval for task scheduler. The iOS BGTaskScheduler does not guarantee that the number of minutes will be
    * exact, but it indicates when we'd like the task to start. This will be set to at least 12 hours
+   * PATCH: 15 minutes
    */
-  private static var intervalSeconds: TimeInterval = 12 * 60 * 60
+  private static var intervalSeconds: TimeInterval = 15 * 60
 
   /**
    * Call when a task is registered to keep track of how many background task consumers we have
@@ -21,6 +22,14 @@ public class BackgroundTaskScheduler {
       intervalSeconds = Double(minutes) * 60
     }
     numberOfRegisteredTasksOfThisType += 1
+
+    print("tlonDebug: did register, count is now \(numberOfRegisteredTasksOfThisType)")
+
+    if numberOfRegisteredTasksOfThisType == 1 {
+      Task {
+        try await tryScheduleWorker()
+      }
+    }
   }
 
   /**
@@ -28,6 +37,7 @@ public class BackgroundTaskScheduler {
    */
   public static func didUnregisterTask() {
     numberOfRegisteredTasksOfThisType -= 1
+    print("tlonDebug: did unregister, count is now \(numberOfRegisteredTasksOfThisType)")
   }
 
   /**
@@ -43,17 +53,15 @@ public class BackgroundTaskScheduler {
     await stopWorker()
 
     // Create request
-    let request = BGProcessingTaskRequest(identifier: BackgroundTaskConstants.BackgroundWorkerIdentifier)
-
-    // We'll require network but accept running on battery power.
-    request.requiresNetworkConnectivity = true
-    request.requiresExternalPower = false
+    let request = BGAppRefreshTaskRequest(identifier: BackgroundTaskConstants.BackgroundWorkerIdentifier)
 
     // Set up mimimum start date
-    request.earliestBeginDate = Date().addingTimeInterval(intervalSeconds)
+    // request.earliestBeginDate = Date().addingTimeInterval(intervalSeconds)
+    request.earliestBeginDate = nil
 
     do {
       try BGTaskScheduler.shared.submit(request)
+        print("tlonDebug: submitted task request")
     } catch let error as BGTaskScheduler.Error {
       switch error.code {
       case .unavailable:
@@ -77,6 +85,7 @@ public class BackgroundTaskScheduler {
    */
   public static func stopWorker() async {
     BGTaskScheduler.shared.cancel(taskRequestWithIdentifier: BackgroundTaskConstants.BackgroundWorkerIdentifier)
+    print("tlonDebug: canceled task request")
   }
 
   /**
@@ -84,7 +93,9 @@ public class BackgroundTaskScheduler {
    */
   public static func isWorkerRunning() async -> Bool {
     let requests = await BGTaskScheduler.shared.pendingTaskRequests()
-    return requests.contains(where: { $0.identifier == BackgroundTaskConstants.BackgroundWorkerIdentifier })
+    let isRunning = requests.contains(where: { $0.identifier == BackgroundTaskConstants.BackgroundWorkerIdentifier })
+    print("tlonDebug: checked is worker running? \(isRunning)")
+    return isRunning
   }
 
   /**
diff --git a/plugin/tsconfig.tsbuildinfo b/plugin/tsconfig.tsbuildinfo
new file mode 100644
index 0000000000000000000000000000000000000000..3805c9b246dc846502d96d39db274d281a673b6f
--- /dev/null
+++ b/plugin/tsconfig.tsbuildinfo
@@ -0,0 +1 @@
+{"root":["./src/withbackgroundtask.ts"],"version":"5.9.2"}
\ No newline at end of file
diff --git a/src/BackgroundTask.ts b/src/BackgroundTask.ts
index d4ee89084d233740d59a30886fea842d3f5e3e25..18a934722ce1b93b36e4b29116f3225ca8f77c01 100644
--- a/src/BackgroundTask.ts
+++ b/src/BackgroundTask.ts
@@ -103,17 +103,17 @@ export async function unregisterTaskAsync(taskName: string): Promise<void> {
  * @todo(chrfalch): When we have a usable devtools plugin we can enable this function.
  * @returns A promise which fulfils when the task is triggered.
  */
-// export async function triggerTaskWorkerForTestingAsync(): Promise<boolean> {
-//   if (__DEV__) {
-//     if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {
-//       throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');
-//     }
-//     console.log('Calling triggerTaskWorkerForTestingAsync');
-//     return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();
-//   } else {
-//     return Promise.resolve(false);
-//   }
-// }
+export async function triggerTaskWorkerForTestingAsync(): Promise<boolean> {
+  if (__DEV__) {
+    if (!ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync) {
+      throw new UnavailabilityError('BackgroundTask', 'triggerTaskWorkerForTestingAsync');
+    }
+    console.log('Calling triggerTaskWorkerForTestingAsync');
+    return await ExpoBackgroundTaskModule.triggerTaskWorkerForTestingAsync();
+  } else {
+    return Promise.resolve(false);
+  }
+}
 
 // Export types
 export {
